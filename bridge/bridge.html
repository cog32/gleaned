<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Gleaned Bridge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
        background: #f6f7fb;
        color: #333;
      }
      main {
        text-align: center;
        padding: 2rem;
      }
      h1 {
        font-size: 1.25rem;
        margin-bottom: 0.5rem;
      }
      p {
        margin: 0;
        font-size: 0.95rem;
        color: #555;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Gleaned Bridge</h1>
      <p>Keep this tab open while we send your contentâ€¦</p>
    </main>

    <script>
      // Register service worker first
      async function registerServiceWorker() {
        if ('serviceWorker' in navigator) {
          try {
            console.log('[Bridge] Registering service worker...');
            const registration = await navigator.serviceWorker.register('/sw.js?v=' + Date.now(), {
              scope: '/'
            });
            console.log('[Bridge] Service Worker registered:', registration.scope);
            await navigator.serviceWorker.ready;
            console.log('[Bridge] Service Worker is ready');
          } catch (error) {
            console.warn('[Bridge] Service Worker registration failed:', error);
          }
        }
      }

      // Verify service worker is actively handling requests (Safari fix)
      async function verifyServiceWorkerActive(maxAttempts = 10, initialDelay = 50) {
        if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) {
          console.log('[Bridge] No service worker controller, skipping verification');
          return;
        }

        console.log('[Bridge] Verifying service worker is active...');
        let attempt = 0;
        let delay = initialDelay;

        while (attempt < maxAttempts) {
          try {
            // Do a test fetch to verify SW is intercepting requests
            const testUrl = '/push?_test=1';
            const response = await fetch(testUrl, {
              method: 'HEAD',
              cache: 'no-store'
            });

            // If we get any response (even 405 Method Not Allowed), SW is active
            console.log('[Bridge] Service worker verified active (status: ' + response.status + ')');
            return;
          } catch (error) {
            attempt++;
            if (attempt >= maxAttempts) {
              console.warn('[Bridge] Service worker verification failed after ' + maxAttempts + ' attempts:', error);
              return;
            }
            console.log('[Bridge] Service worker not yet active, retrying in ' + delay + 'ms... (attempt ' + attempt + ')');
            await new Promise(resolve => setTimeout(resolve, delay));
            delay = Math.min(delay * 2, 500); // Exponential backoff, max 500ms
          }
        }
      }

      (async () => {
        // Register service worker before doing anything else
        await registerServiceWorker();

        // Verify service worker is actively handling requests (critical for Safari)
        await verifyServiceWorkerActive();

        const BRIDGE_ORIGIN = window.location.origin;
        const hostOrigins = new Set();
        const hostTargets = new Map();
        console.log('[Bridge] boot', { origin: BRIDGE_ORIGIN });

        function postToOpener(message, targetOrigin = '*') {
          if (window.opener) {
            window.opener.postMessage(message, targetOrigin);
          }
        }

        function allowOrigin(origin) {
          if (!origin) return false;
          if (hostOrigins.has(origin)) return true;
          hostOrigins.add(origin);
          return true;
        }

        function isAllowedOrigin(origin) {
          return hostOrigins.has(origin);
        }

        function rememberHost(origin, targetWindow) {
          if (!origin || !targetWindow) return;
          hostTargets.set(origin, targetWindow);
          console.log('[Bridge] remembered host', origin);
        }

        function notifyHostsReady() {
          for (const [origin, targetWindow] of hostTargets.entries()) {
            try {
              targetWindow?.postMessage({ type: 'READY', bridgeOrigin: BRIDGE_ORIGIN }, origin);
              console.log('[Bridge] sent READY to remembered host', origin);
            } catch (_) { /* ignore */ }
          }
          postToOpener({ type: 'READY', bridgeOrigin: BRIDGE_ORIGIN }, '*');
        }

        function normalizeRedirect(path) {
          if (!path) return '/ingest';
          return path.startsWith('/') ? path : '/' + path;
        }

        async function handleBridgeCall(evt, data) {
          const { id, action, payload } = data;
          if (!id) return;

          if (action === 'push-content') {
            try {
              const response = await fetch('/push', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload || {})
              });

              let result = null;
              try { result = await response.json(); } catch (_) { result = null; }

              const success = response.ok && result ? !!result.success : response.ok;
              const redirectTo = result && result.redirectTo ? normalizeRedirect(result.redirectTo) : '/ingest';

              const message = {
                type: 'BRIDGE_RESPONSE',
                id,
                result: {
                  success,
                  redirectTo,
                  status: response.status,
                  error: result && result.error ? result.error : undefined
                }
              };

              if (!success) {
                message.error = result && result.error ? result.error : 'HTTP ' + response.status;
              }

              console.log('[Bridge] POST /push response', { success, status: response.status, redirectTo });

              const targetOrigin = evt.origin || '*';
              try { evt.source?.postMessage(message, targetOrigin); } catch (err) { console.warn('[Bridge] postMessage to source failed', err); }
              try { postToOpener(message, targetOrigin); } catch (err) { console.warn('[Bridge] postMessage to opener failed', err); }

              if (success) {
                const redirectMessage = { type: 'BRIDGE_REDIRECT', redirectTo };
                try { evt.source?.postMessage(redirectMessage, targetOrigin); } catch (_) {}
                try { postToOpener(redirectMessage, targetOrigin); } catch (_) {}
              }
            } catch (err) {
              console.error('[Bridge] BRIDGE_CALL error', err);
              const targetOrigin = evt.origin || '*';
              const errorMessage = { type: 'BRIDGE_RESPONSE', id, error: err && err.message ? err.message : String(err) };
              try { evt.source?.postMessage(errorMessage, targetOrigin); } catch (_) {}
              try { postToOpener(errorMessage, targetOrigin); } catch (_) {}
            }
          }
        }

        // Immediately notify any opener and later-registered hosts once SW is verified
        notifyHostsReady();

        window.addEventListener('message', (evt) => {
          const data = evt.data || {};

          if (data.type === 'REGISTER_HOST') {
            console.log('[Bridge] REGISTER_HOST from', evt.origin, data);
            const allowed = allowOrigin(evt.origin);
            if (!allowed) {
              evt.source?.postMessage({ type: 'ERROR', message: 'Origin not permitted' }, evt.origin);
            } else {
              rememberHost(evt.origin, evt.source);
              try {
                evt.source?.postMessage({ type: 'READY', bridgeOrigin: BRIDGE_ORIGIN }, evt.origin);
                console.log('[Bridge] READY ->', evt.origin);
              } catch (_) { /* ignore */ }
            }
            return;
          }

          if (!isAllowedOrigin(evt.origin)) {
            if (!allowOrigin(evt.origin)) {
              if (data.type === 'BRIDGE_CALL') {
                evt.source?.postMessage({ type: 'ERROR', message: 'Unauthorized bridge request' }, evt.origin);
              }
              console.warn('[Bridge] rejected message from unregistered origin', evt.origin, data);
              return;
            } else {
              rememberHost(evt.origin, evt.source);
              try { evt.source?.postMessage({ type: 'READY', bridgeOrigin: BRIDGE_ORIGIN }, evt.origin); } catch (_) {}
            }
          }

          if (data.type === 'BRIDGE_CALL') {
            console.log('[Bridge] BRIDGE_CALL', evt.origin, data.action);
            handleBridgeCall(evt, data);
            return;
          }

          // Always inform the opener if we did not handle a message.
          evt.source?.postMessage({ type: 'BRIDGE_RESPONSE', id: data.id, error: 'Unhandled message type' }, evt.origin);
        });
      })();
    </script>
  </body>
</html>
